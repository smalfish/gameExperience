[1,["a3zQCfCrBCDZJ4uf2rk5u8","9cD+BPH8JJjbOi+3cgeffb@6c48a","d8yXWzGyZGHKOltah41dBF","baYom81gtHlZHrw+KV5S33@63569","eeFDlMLhhNragchF17HKsO","b8Ubp8MGJAAKGn0YPe4rsH","90gtxhdvxPKbGS6QxSWosX","e59tbpozdDjIV2Em/6femi","67zWr1KidGQbF6IcZT1XaZ","eaKhS9MVZLCIcWaarsRTs2","bcQVUCs2REU5FUuRUvrnBo","9cSfUKvihFTL5+tUpZSrxf","6fRYqVD2xNu6tA6jjHK0tj","4b5o/ob+tA+r9aghW26ygX","a604vFVnFHGoF7aroOFD19","705K5Mjk5Hf5t6ZMZ489Hh@e3734","04+fBkmIZCqLhWSvDz40Iq@6c48a","e183UypwhADIBGfcNA4och@6c48a","820RbWj7VOibiFAXA+5ZJs","f59DUL1lRDXqWIYUoz+C1D@6c48a"],["node","_effectAsset","mainTexture","_mesh","_cameraComponent","scriptMapManager","scene","causticTexture","surfaceWaterDepth"],[["cc.Node",["_name","_id","_layer","_parent","_components","_children","_lpos","_lscale","_lrot","_euler"],0,1,9,2,5,5,5,5],["cc.Camera",["_priority","_visibility","_clearFlags","_projection","_orthoHeight","_far","_name","_fov","node","_color","__prefab"],-5,1,5,4],["cc.Material",["_states","_defines","_techIdx","_props"],0,12],["cc.Node",["_name","_id","_layer","_parent","_components","_lpos"],0,1,2,5],["cc.SceneAsset",["_name"],2],["cc.Scene",["_children","_prefab","_globals"],3,2,4,4],["cc.PrefabInfo",["targetOverrides"],2],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",["_skyIllum","_skyColor"],2,5],["cc.ShadowsInfo",["_type","_enabled","_autoAdapt","_pcf","_bias","_near","_far","_orthoSize","_shadowColor","_size"],-5,5,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_type","_fogDensity","_fogStart","_fogEnd","_fogAtten","_fogColor"],-2,5],["cc.Node",["_name","_id","_parent","_components","_lpos"],1,1,12,5],["cc.UITransform",["node","__prefab","_contentSize"],3,1,4,5],["cc.CompPrefabInfo",["fileId"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.Widget",["_alignFlags","node","__prefab"],2,1,4],["9c488okuNlK47jDPrFi5qUV",["node"],3,1],["ac6b4vOSxdOpKbzE6jegY3f",["_enabled","node"],2,1],["cc.DirectionalLight",["_colorTemperature","_illuminance","node","_staticSettings"],1,1,4],["cc.StaticLightSettings",[],3],["cc.MeshRenderer",["node","__prefab","_materials","lightmapSettings","_mesh"],3,1,4,3,4,6],["cc.ModelLightmapSettings",[],3],["b3b8f8MvnZBabYcFYlL29Be",["node","oriPosOffset","minPosOffset"],3,1,5,5],["5d284TJIoJED67OcSTKXsrV",["node","camera","scriptMapManager","ndSkyBox","ndWater","ndLight"],3,1,1,1,1,1,1],["876a6MZuqRM3JfSTFkqsS3z",["arrNumItemMaterial"],3,3],["554baRvdXVCaZZeXFSvvApe",["node"],3,1],["cc.Mesh",["_native","_dataLength","_hash","_struct"],0,11],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[2,2,0,1,3,4],[14,0,2],[2,0,1,3,3],[0,0,1,3,4,3],[21,0,1,2,3,4,1],[22,1],[27,0,1,2,3,4],[4,0,2],[5,0,1,2,1],[6,0,2],[7,0,1,2,3,1],[8,0,1,2],[9,0,1,2,3,4,5,6,7,8,9,9],[10,1],[11,0,1,2,3,4,5,6],[0,0,2,1,3,5,4,6,4],[0,0,2,1,3,5,7,4],[0,0,1,3,4,6,8,9,3],[0,0,1,3,5,6,7,3],[0,0,2,3,4,8,7,9,3],[0,0,3,5,2],[0,0,3,4,8,9,2],[0,0,2,1,3,4,6,4],[12,0,1,2,3,4,3],[3,0,1,3,4,3],[3,0,2,3,4,5,3],[13,0,1,2,1],[15,0,1,2,1],[16,0,1,2,2],[17,0,1],[1,0,1,8,3],[1,3,0,4,5,2,1,8,9,7],[1,6,0,7,2,1,8,10,9,6],[18,0,1,2],[19,0,1,2,3,3],[20,1],[23,0,1,2,1],[24,0,1,2,3,4,5,1],[25,0,1],[26,0,1],[28,0,1,2,4]],[[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.9,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[7,"fight"],[8,[-1,-2,-3,-4,-5,-6,-7,-8,-9],[9,[]],[10,[11,50000,[4,33554431]],[12,1,true,false,3,0.001,5,20,4,[4,4278190080],[0,2048,2048]],[13],[14,1,0.1,0.1,1000,1000,[4,4294965998]]]],[15,"Canvas",33554432,"fe//+i229FN73thz89SHAp",1,[-15],[[26,-10,[1,"0dngp/9gNO34wUQjZfN/CX"],[5,720,1280]],[27,-12,[1,"3f2oTdCepERZdpmIfLsrhd"],-11],[28,45,-13,[1,"e8a+bU/8dPDbbJguUzLdoF"]],[29,-14]],[1,360,640,0]],[23,"Main Camera","c9DMICJLFO5IeO07EPon7U",1,[[[30,1,1083179008,-16],-17,[33,false,-18]],4,1,4],[1,0,3,21.5]],[16,"skyBox",8388608,"75TGN5AbxO64m7aZFUAN5T",1,[-19],[1,4,4,4]],[17,"Main Light","85Gbj+sYhPjqbUFvhCZop+",1,[[34,7500,170000,-20,[35]]],[1,4.5,8,3.8],[3,-0.31945927355932713,0.3289131696384912,0.2230776823820293,0.8602315077921587],[1,-45,46,10]],[18,"waterPlane","82uCAX4tJEsZ62C82TbZN5",1,[-21],[1,0,0.8,0],[1,4,4,4]],[19,"skyBox",8388608,4,[[4,-22,[1,"f4bm6zrYJFZrjY1uGAuUhM"],[0],[5],1]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,0.034,0.034,0.034],[1,-90.00000000000003,0,0]],[36,3,[1,0.2,0.8,1.5],[1,0.2,1.3,2]],[3,"gameManager","e7Tkz7psxFd6PAFTSpqn/B",1,[[37,-24,8,-23,4,6,5]]],[38,[2,3,4,5,6,7,8,9,10,11]],[24,"map","f4V892549A0ayixpoktEiz",1,[10]],[20,"RootNode",6,[-25]],[21,"waterPlane",12,[[4,-26,[1,"1by20MZeFA2ZehuPa6wiUj"],[12],[5],13]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[3,"effectManager","71ZYi75JNLApUDDjjIK0+y",1,[[39,-27]]],[25,"Camera",33554432,2,[-28],[1,0,0,1000]],[31,0,2,640,2000,6,1107296256,15,[4,4278190080]],[22,"Camera3D",524288,"90fV0WQ2xPE4OMyjtQW8/T",1,[[32,"Camera<CameraComponent>",3,60,6,524288,-29,[1,"dbCiGR9T1E0oZwxclTRFEj"],[4,4286073907]]],[1,360,640,636.951]]],0,[0,-1,4,0,-2,3,0,-3,5,0,-4,9,0,-5,14,0,-6,2,0,-7,11,0,-8,6,0,-9,17,0,0,2,0,4,16,0,0,2,0,0,2,0,0,2,0,-1,15,0,0,3,0,-2,8,0,0,3,0,-1,7,0,0,5,0,-1,12,0,0,7,0,5,10,0,0,9,0,-1,13,0,0,13,0,0,14,0,-1,16,0,0,17,0,6,1,10,0,11,29],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,3,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-1,3],[2,3,4,5,6,7,8,9,10,11,12,13,14,15]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.4,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.8,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[6,".bin",204,2851593682,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":12,"count":6,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5,-5,0],"maxPosition",8,[1,5,5,0]]]],0,0,[],[],[]],[[[40,"../res/model/map/water/newwater/water",[{"hash":3483938921,"name":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int16: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n  layout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if USE_LIGHT\nlayout(set = 1, binding = 0) uniform Light {\n  vec4 pbrParams;\n};\n#endif\nlayout(set = 1, binding = 1) uniform Water {\n  vec4 normalParams;\n  vec4 shallowColor;\n  vec4 deepColor;\n  vec4 waveVisuals;\n  vec4 waveDirections;\n  vec4 foamParams;\n  vec4 foamColor;\n  vec4 causticParams1;\n  vec4 causticParams2;\n  float depthDistance;\n  float opacity;\n  float coastOpacity;\n};\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowColor;\n  lowp  vec4 cc_shadowInfo;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 0\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 1\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 2\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nlayout(location = 1) out vec3 v_position;\nlayout(location = 2) out vec4 v_projPos;\nlayout(location = 3) out vec2 v_uv;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out float v_fog_factor;\n#if USE_NORMAL_MAP\n  layout(location = 6) out vec3 v_tangent;\n  layout(location = 7) out vec3 v_bitangent;\n#endif\nvec3 gerstner(vec3 position, float steepness, float wavelength, float speed, float direction, inout vec3 tangent, inout vec3 binormal)\n{\n  direction = direction * 2. - 1.;\n  vec2 d = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n  float s = steepness;\n  float k = 2. * 3.14 / wavelength;\n  float f = k * (dot(d, position.xz) - speed * cc_time.x);\n  float a = s / k;\n  tangent += vec3(\n    -d.x * d.x * s * sin(f),\n    d.x * s * cos(f),\n    -d.x * d.y * s * sin(f)\n  );\n  binormal += vec3(\n    -d.x * d.y * s * sin(f),\n    d.y * s * cos(f),\n    -d.y * d.y * s * sin(f)\n  );\n  return vec3(\n    d.x * a * cos(f),\n    a * sin(f),\n    d.y * a * cos(f)\n  );\n}\nvoid gerstnerWaves(vec3 p, vec3 visuals, vec4 directions, out vec3 offset, out vec3 normal, out vec3 T, out vec3 B)\n{\n    float steepness = visuals.x ;\n    float wavelength = visuals.y;\n    float speed = visuals.z;\n    offset = vec3(0,0,0);\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    offset += gerstner(p, steepness, wavelength, speed, directions.x, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.y, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.z, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.w, tangent, binormal);\n    normal = normalize(cross(binormal, tangent));\n    T = tangent;\n    B = binormal;\n}\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  #if USE_WAVE\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    gerstnerWaves(worldPos.xyz, waveVisuals.xyz, waveDirections, offset, v_normal, tangent, bitangent);\n    worldPos.xyz += offset;\n    #if USE_NORMAL_MAP\n      v_tangent = tangent;\n      v_bitangent = bitangent;\n    #endif\n  #endif\n  v_position = worldPos.xyz;\n  v_projPos = cc_matProj * cc_matView * worldPos;\n  #if !USE_WAVE\n    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n    #if USE_NORMAL_MAP\n      v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n    #endif\n  #endif\n  v_uv = a_texCoord;\n  v_fog_factor = CC_TRANSFER_FOG(worldPos);\n    v_shadowPos = cc_matLightViewProj * worldPos;\n  return v_projPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowColor;\n  lowp  vec4 cc_shadowInfo;\n};\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if CC_RECEIVE_SHADOW\nlayout(location = 0) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n  float CCGetShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n    #if CC_RECEIVE_SHADOW\n      if (cc_lightPos[i].w > 0.0) {\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5();\n      else shadowAttenuation = CCGetDirLightShadowFactorX1();\n      lightColor *= 1.0 - shadowAttenuation;\n    }\n      }\n    #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      finalColor = s.lightmap.a * s.lightmap.rgb + (1.0 - s.lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5();\n      else shadowAttenuation = CCGetShadowFactorX1();\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n    }\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\n#if USE_LIGHT\nlayout(set = 1, binding = 0) uniform Light {\n  vec4 pbrParams;\n};\n#endif\nlayout(set = 1, binding = 1) uniform Water {\n  vec4 normalParams;\n  vec4 shallowColor;\n  vec4 deepColor;\n  vec4 waveVisuals;\n  vec4 waveDirections;\n  vec4 foamParams;\n  vec4 foamColor;\n  vec4 causticParams1;\n  vec4 causticParams2;\n  float depthDistance;\n  float opacity;\n  float coastOpacity;\n};\nlayout(location = 1) in vec3 v_position;\nlayout(location = 2) in vec4 v_projPos;\nlayout(location = 3) in vec2 v_uv;\nlayout(location = 4) in vec3 v_normal;\nlayout(location = 5) in float v_fog_factor;\n#if USE_FOAM\nlayout(set = 1, binding = 3) uniform sampler2D foamTexture;\n#endif\n#if USE_CAUSTIC\nlayout(set = 1, binding = 4) uniform sampler2D causticTexture;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 6) in vec3 v_tangent;\n  layout(location = 7) in vec3 v_bitangent;\n  layout(set = 1, binding = 5) uniform sampler2D normalMap;\n#endif\n#if USE_DEPTH\n  layout(set = 1, binding = 2) uniform FsConstant {\n    vec4 depthGradientShallow;\n    vec4 depthGradientDeep;\n    float depthMaxDistance;\n  };\n  layout(set = 1, binding = 6) uniform sampler2D surfaceWaterDepth;\n#endif\nvec3 normalBlend(vec3 A, vec3 B)\n{\n  return normalize(vec3(A.rg + B.rg, A.b * B.b));\n}\n#if USE_CAUSTIC\nvec2 panner(vec2 uv, float direction, float speed, vec2 offset, float tiling)\n{\n    direction = direction * 2. - 1.;\n    vec2 dir = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n    return  (dir * cc_time.x * speed) + offset + (uv * tiling);\n}\nvec3 rgbSplit(float split, sampler2D tex, vec2 uv)\n{\n    vec2 UVR = uv + vec2(split, split);\n    vec2 UVG = uv + vec2(split, -split);\n    vec2 UVB = uv + vec2(-split, -split);\n    float r = texture(tex, UVR).r;\n    float g = texture(tex, UVG).g;\n    float b = texture(tex, UVB).b;\n    return vec3(r,g,b);\n}\nvec3 caustic()\n{\n  vec2 uv = v_position.xz;\n  float strength = causticParams1.x;\n  float split = causticParams1.w * 0.01;\n  float speed = causticParams1.z;\n  float scale = causticParams1.y;\n  vec3 texture1 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), 1./scale));\n  vec3 texture2 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), -1./scale));\n  vec3 textureCombined = min(texture1, texture2);\n  return strength * 10. * textureCombined;\n}\n#endif\n  vec4 alphaBlend(vec4 top, vec4 bottom)\n{\n  vec3 color = (top.rgb * top.a) + (bottom.rgb * (1. - top.a));\n  float alpha = top.a + bottom.a * (1. - top.a);\n  return vec4(color, alpha);\n}\n#if USE_LIGHT\nvec4 surf (vec4 albedo) {\n  StandardSurface s;\n  s.albedo = albedo;\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    float normalStrenth = normalParams.x;\n    vec2 normalUV = v_uv * normalParams.y;\n    vec2 moveUV = normalUV + normalParams.zw * cc_time.x / 40.;\n    vec3 nmmp = normalBlend(texture(normalMap, moveUV).xyz - vec3(.5), texture(normalMap, normalUV).xyz - vec3(.5));\n    s.normal =\n      (nmmp.x * normalStrenth) * normalize(v_tangent) +\n      (nmmp.y * normalStrenth) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  return CCStandardShading(s);\n}\n#endif\nvec4 frag () {\n  vec4 waterColor = shallowColor;\n  vec4 finalFoamColor = vec4(0.);\n  #if USE_FOAM\n  #endif\n  vec4 finalCausticColor = vec4(0.);\n  #if USE_CAUSTIC\n    float causticDepth = causticParams2.x;\n    vec3 causticColor = causticParams2.yzw;\n    finalCausticColor.rgb = caustic() * causticColor;\n  #endif\n  #if USE_DEPTH\n    float waterDepth = texture(surfaceWaterDepth, v_uv).r;\n    float depth = clamp(1. - waterDepth / depthMaxDistance, 0., 1.);\n    vec4 depthColor = mix(depthGradientShallow, depthGradientDeep, depth);\n    waterColor = alphaBlend(depthColor, waterColor);\n  #endif\n  vec4 finalColor = waterColor + finalFoamColor + finalCausticColor;\n  finalColor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, finalColor.rgb, v_fog_factor), finalColor.a);\n  #if USE_LIGHT\n  finalColor = surf(finalColor);\n  finalColor = CCFragOutput(finalColor);\n  #endif\n  return finalColor;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n  in vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if USE_LIGHT\nlayout(std140) uniform Light {\n  vec4 pbrParams;\n};\n#endif\nlayout(std140) uniform Water {\n  vec4 normalParams;\n  vec4 shallowColor;\n  vec4 deepColor;\n  vec4 waveVisuals;\n  vec4 waveDirections;\n  vec4 foamParams;\n  vec4 foamColor;\n  vec4 causticParams1;\n  vec4 causticParams2;\n  float depthDistance;\n  float opacity;\n  float coastOpacity;\n};\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowColor;\n  lowp  vec4 cc_shadowInfo;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 0\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 1\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 2\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nout vec3 v_position;\nout vec4 v_projPos;\nout vec2 v_uv;\nout vec3 v_normal;\nout float v_fog_factor;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nvec3 gerstner(vec3 position, float steepness, float wavelength, float speed, float direction, inout vec3 tangent, inout vec3 binormal)\n{\n  direction = direction * 2. - 1.;\n  vec2 d = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n  float s = steepness;\n  float k = 2. * 3.14 / wavelength;\n  float f = k * (dot(d, position.xz) - speed * cc_time.x);\n  float a = s / k;\n  tangent += vec3(\n    -d.x * d.x * s * sin(f),\n    d.x * s * cos(f),\n    -d.x * d.y * s * sin(f)\n  );\n  binormal += vec3(\n    -d.x * d.y * s * sin(f),\n    d.y * s * cos(f),\n    -d.y * d.y * s * sin(f)\n  );\n  return vec3(\n    d.x * a * cos(f),\n    a * sin(f),\n    d.y * a * cos(f)\n  );\n}\nvoid gerstnerWaves(vec3 p, vec3 visuals, vec4 directions, out vec3 offset, out vec3 normal, out vec3 T, out vec3 B)\n{\n    float steepness = visuals.x ;\n    float wavelength = visuals.y;\n    float speed = visuals.z;\n    offset = vec3(0,0,0);\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    offset += gerstner(p, steepness, wavelength, speed, directions.x, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.y, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.z, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.w, tangent, binormal);\n    normal = normalize(cross(binormal, tangent));\n    T = tangent;\n    B = binormal;\n}\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  #if USE_WAVE\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    gerstnerWaves(worldPos.xyz, waveVisuals.xyz, waveDirections, offset, v_normal, tangent, bitangent);\n    worldPos.xyz += offset;\n    #if USE_NORMAL_MAP\n      v_tangent = tangent;\n      v_bitangent = bitangent;\n    #endif\n  #endif\n  v_position = worldPos.xyz;\n  v_projPos = cc_matProj * cc_matView * worldPos;\n  #if !USE_WAVE\n    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n    #if USE_NORMAL_MAP\n      v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n    #endif\n  #endif\n  v_uv = a_texCoord;\n  v_fog_factor = CC_TRANSFER_FOG(worldPos);\n    v_shadowPos = cc_matLightViewProj * worldPos;\n  return v_projPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowColor;\n  lowp  vec4 cc_shadowInfo;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if CC_RECEIVE_SHADOW\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n    #if CC_RECEIVE_SHADOW\n      if (cc_lightPos[i].w > 0.0) {\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5();\n      else shadowAttenuation = CCGetDirLightShadowFactorX1();\n      lightColor *= 1.0 - shadowAttenuation;\n    }\n      }\n    #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      finalColor = s.lightmap.a * s.lightmap.rgb + (1.0 - s.lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5();\n      else shadowAttenuation = CCGetShadowFactorX1();\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n    }\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\n#if USE_LIGHT\nlayout(std140) uniform Light {\n  vec4 pbrParams;\n};\n#endif\nlayout(std140) uniform Water {\n  vec4 normalParams;\n  vec4 shallowColor;\n  vec4 deepColor;\n  vec4 waveVisuals;\n  vec4 waveDirections;\n  vec4 foamParams;\n  vec4 foamColor;\n  vec4 causticParams1;\n  vec4 causticParams2;\n  float depthDistance;\n  float opacity;\n  float coastOpacity;\n};\nin vec3 v_position;\nin vec4 v_projPos;\nin vec2 v_uv;\nin vec3 v_normal;\nin float v_fog_factor;\n#if USE_FOAM\nuniform sampler2D foamTexture;\n#endif\n#if USE_CAUSTIC\nuniform sampler2D causticTexture;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_DEPTH\n  layout(std140) uniform FsConstant {\n    vec4 depthGradientShallow;\n    vec4 depthGradientDeep;\n    float depthMaxDistance;\n  };\n  uniform sampler2D surfaceWaterDepth;\n#endif\nvec3 normalBlend(vec3 A, vec3 B)\n{\n  return normalize(vec3(A.rg + B.rg, A.b * B.b));\n}\n#if USE_CAUSTIC\nvec2 panner(vec2 uv, float direction, float speed, vec2 offset, float tiling)\n{\n    direction = direction * 2. - 1.;\n    vec2 dir = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n    return  (dir * cc_time.x * speed) + offset + (uv * tiling);\n}\nvec3 rgbSplit(float split, sampler2D tex, vec2 uv)\n{\n    vec2 UVR = uv + vec2(split, split);\n    vec2 UVG = uv + vec2(split, -split);\n    vec2 UVB = uv + vec2(-split, -split);\n    float r = texture(tex, UVR).r;\n    float g = texture(tex, UVG).g;\n    float b = texture(tex, UVB).b;\n    return vec3(r,g,b);\n}\nvec3 caustic()\n{\n  vec2 uv = v_position.xz;\n  float strength = causticParams1.x;\n  float split = causticParams1.w * 0.01;\n  float speed = causticParams1.z;\n  float scale = causticParams1.y;\n  vec3 texture1 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), 1./scale));\n  vec3 texture2 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), -1./scale));\n  vec3 textureCombined = min(texture1, texture2);\n  return strength * 10. * textureCombined;\n}\n#endif\n  vec4 alphaBlend(vec4 top, vec4 bottom)\n{\n  vec3 color = (top.rgb * top.a) + (bottom.rgb * (1. - top.a));\n  float alpha = top.a + bottom.a * (1. - top.a);\n  return vec4(color, alpha);\n}\n#if USE_LIGHT\nvec4 surf (vec4 albedo) {\n  StandardSurface s;\n  s.albedo = albedo;\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    float normalStrenth = normalParams.x;\n    vec2 normalUV = v_uv * normalParams.y;\n    vec2 moveUV = normalUV + normalParams.zw * cc_time.x / 40.;\n    vec3 nmmp = normalBlend(texture(normalMap, moveUV).xyz - vec3(.5), texture(normalMap, normalUV).xyz - vec3(.5));\n    s.normal =\n      (nmmp.x * normalStrenth) * normalize(v_tangent) +\n      (nmmp.y * normalStrenth) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  return CCStandardShading(s);\n}\n#endif\nvec4 frag () {\n  vec4 waterColor = shallowColor;\n  vec4 finalFoamColor = vec4(0.);\n  #if USE_FOAM\n  #endif\n  vec4 finalCausticColor = vec4(0.);\n  #if USE_CAUSTIC\n    float causticDepth = causticParams2.x;\n    vec3 causticColor = causticParams2.yzw;\n    finalCausticColor.rgb = caustic() * causticColor;\n  #endif\n  #if USE_DEPTH\n    float waterDepth = texture(surfaceWaterDepth, v_uv).r;\n    float depth = clamp(1. - waterDepth / depthMaxDistance, 0., 1.);\n    vec4 depthColor = mix(depthGradientShallow, depthGradientDeep, depth);\n    waterColor = alphaBlend(depthColor, waterColor);\n  #endif\n  vec4 finalColor = waterColor + finalFoamColor + finalCausticColor;\n  finalColor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, finalColor.rgb, v_fog_factor), finalColor.a);\n  #if USE_LIGHT\n  finalColor = surf(finalColor);\n  finalColor = CCFragOutput(finalColor);\n  #endif\n  return finalColor;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n  attribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp vec4 cc_time;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\n#if USE_LIGHT\n#endif\nuniform vec4 waveVisuals;\nuniform vec4 waveDirections;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 0\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 1\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 2\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nvarying vec3 v_position;\nvarying vec4 v_projPos;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\nvarying float v_fog_factor;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvec3 gerstner(vec3 position, float steepness, float wavelength, float speed, float direction, inout vec3 tangent, inout vec3 binormal)\n{\n  direction = direction * 2. - 1.;\n  vec2 d = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n  float s = steepness;\n  float k = 2. * 3.14 / wavelength;\n  float f = k * (dot(d, position.xz) - speed * cc_time.x);\n  float a = s / k;\n  tangent += vec3(\n    -d.x * d.x * s * sin(f),\n    d.x * s * cos(f),\n    -d.x * d.y * s * sin(f)\n  );\n  binormal += vec3(\n    -d.x * d.y * s * sin(f),\n    d.y * s * cos(f),\n    -d.y * d.y * s * sin(f)\n  );\n  return vec3(\n    d.x * a * cos(f),\n    a * sin(f),\n    d.y * a * cos(f)\n  );\n}\nvoid gerstnerWaves(vec3 p, vec3 visuals, vec4 directions, out vec3 offset, out vec3 normal, out vec3 T, out vec3 B)\n{\n    float steepness = visuals.x ;\n    float wavelength = visuals.y;\n    float speed = visuals.z;\n    offset = vec3(0,0,0);\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    offset += gerstner(p, steepness, wavelength, speed, directions.x, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.y, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.z, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.w, tangent, binormal);\n    normal = normalize(cross(binormal, tangent));\n    T = tangent;\n    B = binormal;\n}\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  #if USE_WAVE\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    gerstnerWaves(worldPos.xyz, waveVisuals.xyz, waveDirections, offset, v_normal, tangent, bitangent);\n    worldPos.xyz += offset;\n    #if USE_NORMAL_MAP\n      v_tangent = tangent;\n      v_bitangent = bitangent;\n    #endif\n  #endif\n  v_position = worldPos.xyz;\n  v_projPos = cc_matProj * cc_matView * worldPos;\n  #if !USE_WAVE\n    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n    #if USE_NORMAL_MAP\n      v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n    #endif\n  #endif\n  v_uv = a_texCoord;\n  v_fog_factor = CC_TRANSFER_FOG(worldPos);\n    v_shadowPos = cc_matLightViewProj * worldPos;\n  return v_projPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_time;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform lowp vec4 cc_shadowColor;\nuniform lowp vec4 cc_shadowInfo;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\n#if CC_RECEIVE_SHADOW\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    float shadow = step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n    closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -1; i <= 1; i++) {\n      for (int j = -1; j <= 1; j++) {\n        float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 () {\n    vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowInfo.x;\n    float offsety = 1.0 / cc_shadowInfo.y;\n    float shadow = 0.0;\n    for (int i = -2; i <= 2; i++) {\n      for (int j = -2; j <= 2; j++) {\n        float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        shadow += step(closestDepth, clipPos.z - cc_shadowInfo.w);\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nuniform highp vec4 cc_lightPos[1];\nuniform vec4 cc_lightColor[1];\nuniform vec4 cc_lightSizeRangeAngle[1];\nuniform vec4 cc_lightDir[1];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n    #if CC_RECEIVE_SHADOW\n      if (cc_lightPos[i].w > 0.0) {\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5();\n      else shadowAttenuation = CCGetDirLightShadowFactorX1();\n      lightColor *= 1.0 - shadowAttenuation;\n    }\n      }\n    #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      finalColor = s.lightmap.a * s.lightmap.rgb + (1.0 - s.lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25();\n      else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9();\n      else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5();\n      else shadowAttenuation = CCGetShadowFactorX1();\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n    }\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\n#if USE_LIGHT\nuniform vec4 pbrParams;\n#endif\nuniform vec4 normalParams;\nuniform vec4 shallowColor;\nuniform vec4 causticParams1;\nuniform vec4 causticParams2;\nvarying vec3 v_position;\nvarying vec4 v_projPos;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\nvarying float v_fog_factor;\n#if USE_FOAM\nuniform sampler2D foamTexture;\n#endif\n#if USE_CAUSTIC\nuniform sampler2D causticTexture;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_DEPTH\n  uniform vec4 depthGradientShallow;\nuniform vec4 depthGradientDeep;\nuniform float depthMaxDistance;\n  uniform sampler2D surfaceWaterDepth;\n#endif\nvec3 normalBlend(vec3 A, vec3 B)\n{\n  return normalize(vec3(A.rg + B.rg, A.b * B.b));\n}\n#if USE_CAUSTIC\nvec2 panner(vec2 uv, float direction, float speed, vec2 offset, float tiling)\n{\n    direction = direction * 2. - 1.;\n    vec2 dir = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n    return  (dir * cc_time.x * speed) + offset + (uv * tiling);\n}\nvec3 rgbSplit(float split, sampler2D tex, vec2 uv)\n{\n    vec2 UVR = uv + vec2(split, split);\n    vec2 UVG = uv + vec2(split, -split);\n    vec2 UVB = uv + vec2(-split, -split);\n    float r = texture2D(tex, UVR).r;\n    float g = texture2D(tex, UVG).g;\n    float b = texture2D(tex, UVB).b;\n    return vec3(r,g,b);\n}\nvec3 caustic()\n{\n  vec2 uv = v_position.xz;\n  float strength = causticParams1.x;\n  float split = causticParams1.w * 0.01;\n  float speed = causticParams1.z;\n  float scale = causticParams1.y;\n  vec3 texture1 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), 1./scale));\n  vec3 texture2 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), -1./scale));\n  vec3 textureCombined = min(texture1, texture2);\n  return strength * 10. * textureCombined;\n}\n#endif\n  vec4 alphaBlend(vec4 top, vec4 bottom)\n{\n  vec3 color = (top.rgb * top.a) + (bottom.rgb * (1. - top.a));\n  float alpha = top.a + bottom.a * (1. - top.a);\n  return vec4(color, alpha);\n}\n#if USE_LIGHT\nvec4 surf (vec4 albedo) {\n  StandardSurface s;\n  s.albedo = albedo;\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    float normalStrenth = normalParams.x;\n    vec2 normalUV = v_uv * normalParams.y;\n    vec2 moveUV = normalUV + normalParams.zw * cc_time.x / 40.;\n    vec3 nmmp = normalBlend(texture2D(normalMap, moveUV).xyz - vec3(.5), texture2D(normalMap, normalUV).xyz - vec3(.5));\n    s.normal =\n      (nmmp.x * normalStrenth) * normalize(v_tangent) +\n      (nmmp.y * normalStrenth) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  return CCStandardShading(s);\n}\n#endif\nvec4 frag () {\n  vec4 waterColor = shallowColor;\n  vec4 finalFoamColor = vec4(0.);\n  #if USE_FOAM\n  #endif\n  vec4 finalCausticColor = vec4(0.);\n  #if USE_CAUSTIC\n    float causticDepth = causticParams2.x;\n    vec3 causticColor = causticParams2.yzw;\n    finalCausticColor.rgb = caustic() * causticColor;\n  #endif\n  #if USE_DEPTH\n    float waterDepth = texture2D(surfaceWaterDepth, v_uv).r;\n    float depth = clamp(1. - waterDepth / depthMaxDistance, 0., 1.);\n    vec4 depthColor = mix(depthGradientShallow, depthGradientDeep, depth);\n    waterColor = alphaBlend(depthColor, waterColor);\n  #endif\n  vec4 finalColor = waterColor + finalFoamColor + finalCausticColor;\n  finalColor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, finalColor.rgb, v_fog_factor), finalColor.a);\n  #if USE_LIGHT\n  finalColor = surf(finalColor);\n  finalColor = CCFragOutput(finalColor);\n  #endif\n  return finalColor;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplers":[{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplers":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_SUPPORT_FLOAT_TEXTURE","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHT","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"USE_WAVE","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_FOAM","type":"boolean","defines":[]},{"name":"USE_CAUSTIC","type":"boolean","defines":[]},{"name":"USE_DEPTH","type":"boolean","defines":[]}],"blocks":[{"name":"Light","stageFlags":17,"binding":0,"members":[{"name":"pbrParams","type":16,"count":1}],"defines":["USE_LIGHT"]},{"name":"Water","stageFlags":17,"binding":1,"members":[{"name":"normalParams","type":16,"count":1},{"name":"shallowColor","type":16,"count":1},{"name":"deepColor","type":16,"count":1},{"name":"waveVisuals","type":16,"count":1},{"name":"waveDirections","type":16,"count":1},{"name":"foamParams","type":16,"count":1},{"name":"foamColor","type":16,"count":1},{"name":"causticParams1","type":16,"count":1},{"name":"causticParams2","type":16,"count":1},{"name":"depthDistance","type":13,"count":1},{"name":"opacity","type":13,"count":1},{"name":"coastOpacity","type":13,"count":1}],"defines":[]},{"name":"FsConstant","stageFlags":16,"binding":2,"members":[{"name":"depthGradientShallow","type":16,"count":1},{"name":"depthGradientDeep","type":16,"count":1},{"name":"depthMaxDistance","type":13,"count":1}],"defines":["USE_DEPTH"]}],"samplers":[{"name":"foamTexture","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_FOAM"]},{"name":"causticTexture","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_CAUSTIC"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_NORMAL_MAP"]},{"name":"surfaceWaterDepth","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_DEPTH"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":12,"count":1,"stageFlags":1,"format":42,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_projPos","type":16,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":6,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":7,"defines":["USE_NORMAL_MAP"]}]}],[{"name":"opaque","passes":[{"program":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","properties":{"occlusion":{"type":13,"value":[1],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.1],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[0.5],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",0,13]},"normalTile":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",1,13]},"normalSpeed":{"type":14,"value":[1,0],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",2,14]},"normalMap":{"value":"normal","type":28,"editor":{"parent":"USE_NORMAL_MAP"}},"depthDistance":{"type":13,"value":[1]},"shallowColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"deepColor":{"type":16,"value":[0,0,0,0],"editor":{"type":"color"}},"opacity":{"type":13,"value":[1]},"coastOpacity":{"type":13,"value":[0.5]},"foamColor":{"type":16,"value":[1,1,1,1],"editor":{"parent":"USE_FOAM","type":"color"}},"foamDistance":{"type":13,"value":[0.35],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",0,13]},"foamDensity":{"type":13,"value":[0.5],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",1,13]},"foamTile":{"type":13,"value":[1],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",2,13]},"foamContrast":{"type":13,"value":[0.5],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",3,13]},"waveVisuals":{"type":16,"value":[0.167,7,0.54,1],"editor":{"parent":"USE_WAVE"}},"waveDirections":{"type":16,"value":[0,0.3,0.6,0.67],"editor":{"parent":"USE_WAVE"}},"causticStrength":{"type":13,"value":[0.98],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",0,13]},"causticScale":{"type":13,"value":[2.33],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",1,13]},"causticSpeed":{"type":13,"value":[0.1],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",2,13]},"causticRGBSplit":{"type":13,"value":[0.35],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",3,13]},"causticDepth":{"type":13,"value":[1],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams2",0,13]},"causticColor":{"type":15,"value":[1,1,1],"editor":{"parent":"USE_CAUSTIC","type":"color"},"handleInfo":["causticParams2",1,15]},"causticTexture":{"value":"white","type":28,"editor":{"parent":"USE_CAUSTIC"}},"surfaceWaterDepth":{"value":"white","type":28,"editor":{"parent":"USE_DEPTH"}},"depthGradientShallow":{"type":16,"value":[0.325,0.807,0.971,0.725],"editor":{"type":"color","parent":"USE_DEPTH"}},"depthGradientDeep":{"type":16,"value":[0.086,0.407,1,0.749],"editor":{"type":"color","parent":"USE_DEPTH"}},"depthMaxDistance":{"type":13,"value":[1],"editor":{"parent":"USE_DEPTH"}},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.1,0,0]},"normalParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.5,1,1,0]},"foamParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.35,0.5,1,0.5]},"causticParams1":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.98,2.33,0.1,0.35]},"causticParams2":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]}}}]},{"name":"transparent","passes":[{"program":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"occlusion":{"type":13,"value":[1],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.1],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"editor":{"parent":"USE_LIGHT"},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[0.5],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",0,13]},"normalTile":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",1,13]},"normalSpeed":{"type":14,"value":[1,0],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["normalParams",2,14]},"normalMap":{"value":"normal","type":28,"editor":{"parent":"USE_NORMAL_MAP"}},"depthDistance":{"type":13,"value":[1]},"shallowColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"deepColor":{"type":16,"value":[0,0,0,0],"editor":{"type":"color"}},"opacity":{"type":13,"value":[1]},"coastOpacity":{"type":13,"value":[0.5]},"foamColor":{"type":16,"value":[1,1,1,1],"editor":{"parent":"USE_FOAM","type":"color"}},"foamDistance":{"type":13,"value":[0.35],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",0,13]},"foamDensity":{"type":13,"value":[0.5],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",1,13]},"foamTile":{"type":13,"value":[1],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",2,13]},"foamContrast":{"type":13,"value":[0.5],"editor":{"parent":"USE_FOAM"},"handleInfo":["foamParams",3,13]},"waveVisuals":{"type":16,"value":[0.167,7,0.54,1],"editor":{"parent":"USE_WAVE"}},"waveDirections":{"type":16,"value":[0,0.3,0.6,0.67],"editor":{"parent":"USE_WAVE"}},"causticStrength":{"type":13,"value":[0.98],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",0,13]},"causticScale":{"type":13,"value":[2.33],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",1,13]},"causticSpeed":{"type":13,"value":[0.1],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",2,13]},"causticRGBSplit":{"type":13,"value":[0.35],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams1",3,13]},"causticDepth":{"type":13,"value":[1],"editor":{"parent":"USE_CAUSTIC"},"handleInfo":["causticParams2",0,13]},"causticColor":{"type":15,"value":[1,1,1],"editor":{"parent":"USE_CAUSTIC","type":"color"},"handleInfo":["causticParams2",1,15]},"causticTexture":{"value":"white","type":28,"editor":{"parent":"USE_CAUSTIC"}},"surfaceWaterDepth":{"value":"white","type":28,"editor":{"parent":"USE_DEPTH"}},"depthGradientShallow":{"type":16,"value":[0.325,0.807,0.971,0.725],"editor":{"type":"color","parent":"USE_DEPTH"}},"depthGradientDeep":{"type":16,"value":[0.086,0.407,1,0.749],"editor":{"type":"color","parent":"USE_DEPTH"}},"depthMaxDistance":{"type":13,"value":[1],"editor":{"parent":"USE_DEPTH"}},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.1,0,0]},"normalParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.5,1,1,0]},"foamParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.35,0.5,1,0.5]},"causticParams1":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.98,2.33,0.1,0.35]},"causticParams2":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]}}}]}]]],0,0,[],[],[]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.2,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.7,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[2,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_WAVE":true,"USE_FOAM":true,"USE_CAUSTIC":true,"USE_DEPTH":true}],[[[{"normalStrenth":1,"opacity":0.5,"causticStrength":0.2,"causticScale":5,"causticSpeed":0.03,"causticRGBSplit":0.6},"shallowColor",8,[4,4294945300],"waveVisuals",8,[2,0.05,1,0.1,0.5],"causticColor",8,[4,4286146051],"depthGradientShallow",8,[4,3103652024],"depthGradientDeep",8,[4,3202979072],"causticTexture",6,0,"surfaceWaterDepth",6,1]],11]]],0,0,[0,0,0],[7,8,1],[16,17,18]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.1,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[6,".bin",32592,3144817543,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26832,"length":5760,"count":2880,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":26832,"count":559,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-138.77093505859375,-138.77093505859375,-138.77093505859375],"maxPosition",8,[1,138.77093505859375,138.77093505859375,138.77093505859375]]]],0,0,[],[],[]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.6,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[2,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[19,0]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.3,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.5,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]]]]
